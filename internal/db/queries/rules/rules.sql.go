// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: rules.sql

package rules

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createRule = `-- name: CreateRule :one
INSERT INTO rules (
    id, tenant_id, name, description, source, event_type, sql, eval_type, alert_level, created_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, tenant_id, name, description, source, event_type, sql, eval_type, alert_level, created_at
`

type CreateRuleParams struct {
	ID          uuid.UUID      `json:"id"`
	TenantID    uuid.UUID      `json:"tenant_id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	Source      string         `json:"source"`
	EventType   string         `json:"event_type"`
	Sql         string         `json:"sql"`
	EvalType    string         `json:"eval_type"`
	AlertLevel  string         `json:"alert_level"`
	CreatedAt   time.Time      `json:"created_at"`
}

func (q *Queries) CreateRule(ctx context.Context, arg CreateRuleParams) (Rule, error) {
	row := q.db.QueryRowContext(ctx, createRule,
		arg.ID,
		arg.TenantID,
		arg.Name,
		arg.Description,
		arg.Source,
		arg.EventType,
		arg.Sql,
		arg.EvalType,
		arg.AlertLevel,
		arg.CreatedAt,
	)
	var i Rule
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Description,
		&i.Source,
		&i.EventType,
		&i.Sql,
		&i.EvalType,
		&i.AlertLevel,
		&i.CreatedAt,
	)
	return i, err
}

const deleteRule = `-- name: DeleteRule :exec
DELETE FROM rules WHERE id = $1 AND tenant_id = $2
`

type DeleteRuleParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteRule(ctx context.Context, arg DeleteRuleParams) error {
	_, err := q.db.ExecContext(ctx, deleteRule, arg.ID, arg.TenantID)
	return err
}

const getRuleByID = `-- name: GetRuleByID :one
SELECT id, tenant_id, name, description, source, event_type, sql, eval_type, alert_level, created_at
FROM rules
WHERE id = $1 AND tenant_id = $2
`

type GetRuleByIDParams struct {
	ID       uuid.UUID `json:"id"`
	TenantID uuid.UUID `json:"tenant_id"`
}

func (q *Queries) GetRuleByID(ctx context.Context, arg GetRuleByIDParams) (Rule, error) {
	row := q.db.QueryRowContext(ctx, getRuleByID, arg.ID, arg.TenantID)
	var i Rule
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Name,
		&i.Description,
		&i.Source,
		&i.EventType,
		&i.Sql,
		&i.EvalType,
		&i.AlertLevel,
		&i.CreatedAt,
	)
	return i, err
}

const getRulesForEvent = `-- name: GetRulesForEvent :many
SELECT id, tenant_id, name, description, source, event_type, sql, eval_type, alert_level, created_at FROM rules WHERE tenant_id = $1 AND source = $2 AND event_type = $3
`

type GetRulesForEventParams struct {
	TenantID  uuid.UUID `json:"tenant_id"`
	Source    string    `json:"source"`
	EventType string    `json:"event_type"`
}

func (q *Queries) GetRulesForEvent(ctx context.Context, arg GetRulesForEventParams) ([]Rule, error) {
	rows, err := q.db.QueryContext(ctx, getRulesForEvent, arg.TenantID, arg.Source, arg.EventType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Rule
	for rows.Next() {
		var i Rule
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Description,
			&i.Source,
			&i.EventType,
			&i.Sql,
			&i.EvalType,
			&i.AlertLevel,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRules = `-- name: ListRules :many
SELECT id, tenant_id, name, description, source, event_type, sql, eval_type, alert_level, created_at
FROM rules
WHERE tenant_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListRulesParams struct {
	TenantID uuid.UUID `json:"tenant_id"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

func (q *Queries) ListRules(ctx context.Context, arg ListRulesParams) ([]Rule, error) {
	rows, err := q.db.QueryContext(ctx, listRules, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Rule
	for rows.Next() {
		var i Rule
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Name,
			&i.Description,
			&i.Source,
			&i.EventType,
			&i.Sql,
			&i.EvalType,
			&i.AlertLevel,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
